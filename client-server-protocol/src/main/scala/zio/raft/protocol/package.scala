package zio.raft

import zio.prelude.*
import zio.*

/** Protocol definitions for ZIO Raft client-server communication.
  *
  * This package provides:
  *   - Message definitions for client-server communication
  *   - scodec-based binary serialization codecs
  *   - Common types and newtypes for type safety
  *   - Protocol versioning and compatibility utilities
  */
package object protocol {

  // Protocol version for backward compatibility
  val PROTOCOL_VERSION: Byte = 1

  // Protocol signature for message identification
  val PROTOCOL_SIGNATURE: Array[Byte] = Array(0x7a, 0x72, 0x61, 0x66, 0x74) // "zraft"

  // ============================================================================
  // SESSION AND REQUEST IDENTIFICATION
  // ============================================================================

  /** Unique identifier for client sessions generated by the server.
    *
    * Sessions are durable and persist across client reconnections and leader changes. The server generates UUIDs to
    * ensure global uniqueness across the cluster.
    */
  object SessionId extends Newtype[String] {

    /** Generate a new unique session ID (pure ZIO version).
      *
      * Uses UUID v4 for cryptographically strong uniqueness guarantees across distributed servers and time periods.
      */
    def generate(): UIO[SessionId] = Random.nextUUID.map(uuid => SessionId(uuid.toString))

    /** Create a SessionId from a string (for testing/deserialization).
      */
    def fromString(id: String): SessionId = {
      require(id.nonEmpty, "Session ID cannot be empty")
      SessionId(id)
    }
  }

  type SessionId = SessionId.Type

  /** Unique identifier for requests used for deduplication and correlation.
    *
    * RequestIds must be generated by the originating party:
    *   - Client: manages its own counter using Ref[Long] for thread-safety
    *   - Server: request ID management is implementation-specific (out of scope)
    *
    * RequestIds must be unique within the session scope to ensure proper correlation.
    */
  object RequestId extends Newtype[Long] {

    /** Zero request ID constant.
      */
    val zero: RequestId = RequestId(0L)

    val max: RequestId = RequestId(Long.MaxValue)

    /** Create a RequestId from a long value (for testing/deserialization).
      */
    def fromLong(id: Long): RequestId = {
      require(id >= 0L, "Request ID must be non-negative")
      RequestId(id)
    }

    /** Syntax extensions for RequestId instances.
      */
    implicit class RequestIdSyntax(private val requestId: RequestId) extends AnyVal {

      /** Get the next request ID by incrementing by one.
        */
      def next: RequestId = RequestId(RequestId.unwrap(requestId) + 1L)

      /** Get the value of the request ID.
        */
      def value: Long = RequestId.unwrap(requestId)

      def isLowerOrEqual(other: RequestId): Boolean = value <= other.value
    }
  }

  type RequestId = RequestId.Type

  // MemberId and RoutingId removed - using types from zio.raft and zio.zmq directly

  // ============================================================================
  // CONFIGURATION AND TIMEOUTS
  // ============================================================================

  // Use zio.Duration directly instead of a custom TimeoutDuration wrapper

  // ============================================================================
  // CLUSTER MEMBER IDENTIFICATION
  // ============================================================================

  /** Type-safe member identifier for cluster member references.
    */
  object MemberId extends Newtype[String] {

    /** Create from string value.
      */
    def fromString(id: String): MemberId = MemberId(id)
  }

  type MemberId = MemberId.Type

  /** Type-safe nonce for request/response correlation.
    */
  object Nonce extends Newtype[Long] {

    /** Generate a cryptographically secure random nonce (pure ZIO version).
      */
    def generate(): UIO[Nonce] = {
      Random.nextLong.map { value =>
        // Ensure non-zero (zero is reserved for "no nonce")
        Nonce(if (value == 0L) 1L else value)
      }
    }

    /** Create from long value (for testing).
      */
    def fromLong(value: Long): Nonce = {
      require(value != 0L, "Nonce cannot be zero")
      Nonce(value)
    }
  }

  type Nonce = Nonce.Type

  // ============================================================================
  // CAPABILITY MANAGEMENT
  // ============================================================================

  /** Type-safe wrapper for client capability definitions.
    *
    * Capabilities are key-value pairs that describe what functionality a client supports, used by the server for work
    * dispatch routing.
    */
  object ClientCapabilities extends Newtype[Map[String, String]] {

    /** Create from key-value pairs.
      */
    def of(pairs: (String, String)*): ClientCapabilities = {
      val capabilities = pairs.toMap
      require(capabilities.nonEmpty, "Capabilities cannot be empty")
      require(
        capabilities.keys.forall(_.matches("[a-zA-Z0-9-_]+")),
        "Capability names must contain only alphanumeric characters, hyphens, and underscores"
      )
      require(
        capabilities.values.forall(_.nonEmpty),
        "Capability values cannot be empty"
      )
      ClientCapabilities(capabilities)
    }

    /** Syntax extensions for ClientCapabilities instances.
      */
    implicit class ClientCapabilitiesSyntax(private val capabilities: ClientCapabilities) extends AnyVal {

      /** Check if a capability is present.
        */
      def has(name: String): Boolean = {
        ClientCapabilities.unwrap(capabilities).contains(name)
      }

      /** Get the value of a capability.
        */
      def get(name: String): Option[String] = {
        ClientCapabilities.unwrap(capabilities).get(name)
      }

      /** Get the value of a capability with a default.
        */
      def getOrElse(name: String, default: String): String = {
        ClientCapabilities.unwrap(capabilities).getOrElse(name, default)
      }

      /** Get all capability names.
        */
      def names: Set[String] = {
        ClientCapabilities.unwrap(capabilities).keySet
      }

      /** Get the number of capabilities.
        */
      def size: Int = {
        ClientCapabilities.unwrap(capabilities).size
      }
    }
  }

  type ClientCapabilities = ClientCapabilities.Type
}
